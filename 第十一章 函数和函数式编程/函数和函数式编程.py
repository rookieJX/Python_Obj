# 11.1 什么是函数
函数是对程序逻辑进行结构化或过程化的一种编程方法。
    | 函数 VS 过程
    我们经常拿函数可过程比较。两者都是可以被调用的实体，但是传统意义上的函数或者“黑盒”，可能不带任何输入参数，经过一定的处理，最后向调用者传回返回值。其中一些函数则是布尔类型的，返回一个“是”或者“否”的回答，更确切的说，一个非零或者零值。而过程是简单、特殊、没有返回的函数。
    | 返回值与函数类型
    函数会向调用者返回一个值，而实际编程中大部分偏函数更接近过程，不显示的返回任何东西。把过程看待成函数的语言通常对于“什么都不返回“的函数设定了特殊的类型或者值的名字。
    Python里的函数可以返回一个值或者对象。只是在返回一个容器对象的时候有点不同，看起来像是能返回多个对象。（比如：你不能拿着大量零散的商品离开商店，但是你可以将他们放在一个购物袋中，然后带着袋子离开商店）
    当没有显示的返回元素或者如果返回None时，Python会返回一个None。那么调用者接收的就是Python返回的那个对象，且对象的类型仍然相同。
    如果函数返回多个对象，Python把他们聚集起来并以一个元组返回。
# 11.2 调用函数
    | 函数操作符
    用一堆圆括号调用函数。
    | 关键字参数
    关键字参数概念仅仅针对函数的调用。
    def foo(x):
        foo_suit
    标准调用foo(): foo(42) foo('bar') foo(y)
    关键字调用foo(): foo(x=2) foo(x='bar') foo(x=y)
    | 默认参数
    默认参数就是声明了默认值的参数。因为给参数赋予了默认值，所以在函数调用时，不响该参数传入值也是允许的。
    | 参数组
    Python同样允许程序员执行一个没有显示定义参数的函数，响应的方法是通过一个把元组（非关键字参数）或字典（关键字参数）作为参数组传递给函数。
    func(*tuple_grp_nonkw_args,**dict_grp_kw_args)
    其中tupletuple_grp_nonkw_args是以元组形式体现的非关键字参数，
    dict_grp_kw_args是装有关键字参数的字典。
    实际上也可以给出形参，这些参数包括标准的位置参数和关键字参数，所以在Python中完整的语法是：
    func(position_args,keyword_args,*tuple_grp_nonkw_args,**dict_grp_kw_args)

    例如：easyMath.py函数中
# 11.3 创建函数
    | def语句
    函数是用 def 语句来创建的
    | 声明与定义比较
    在一些编程语言中，函数声明和函数定义是分开的。一个函数声明包括提供对函数名，参数的名字（传统上还有参数的类型），但不必给出函数的任何代码，具体的代码通常属于函数定义的范畴。
    在声明和定义有区别的语言中，往往是因为函数的定义可能和其声明放在不同的文件中。Python将这两者视为一体，函数的子句由声明的标题行以及随后的定义体组成。
    | 前向引用
    Python不允许在函数未声明之前对其进行引用或者调用。
    | 函数属性
    你可以获得每个Python模块、类和函数中任意的名称空间。你可以在模块foo和bar里都有名为x的一个变量，但是在将这两个模块导入你的程序后，仍然可以使用这两个变量。所以，即使在两个模块中使用了相同的变量名字，这也是安全的，因为句点属性标识对于两个模块意味了不同的命名空间
    函数属性是Python另外一个使用了句点标识并拥有名称空间的领域
    | 内部/内嵌函数
    在函数体内创建另外一个函数（对象）是完全合法的。这种函数叫做内部/内嵌函数。因为Python现在支持静态的嵌套域
        创建一个内嵌函数
        def foo():
            def bar():
                print 'bar() called'
            print 'foo() called'
            bar()
        foo()
        bar()

        例如：inner.py
    内部函数有意思的方面在于整个函数体都在外部函数的作用域（即是你可以访问一个对象的区域）之内如果没有任何 bar() 的外部引用，那么除了在函数体内，任何地方都不能对其进行调用。
    | 函数（与方法）装饰器
    装饰器背后的主要动机源自Python面向对象编程。装饰器是在函数调用之上的修饰。这些修饰仅仅是当声明一个函数或者方法的时候，才会应用的额外调用。
    装饰器的语法是以 @ 开头，接着是装饰器函数的名字和可选参数。紧跟着装饰器声明的是被装饰函数和装饰函数的可选参数。
    @decorator(dec_opt_args)
    def func2Bdecorated(func_opt_args):
    :
    装饰器语法是如何产生的呢？
    在以前当静态方法和类方法被加入到Python中的时候，实现方法很笨拙
        class MyClass(object):
            def staticFoo():
                :
            staticFoo = staticmethod(staticFoo)
                :
    在这个类的声明中，我们定义了叫 staticFoo() 的方法。现在因为打算让他成为静态方法。接着用 staticmethod() 内建函数来将这个函数“转化”为静态方法，但是在 def staticFoo() 后跟着 staticFoo = staticmethod(sta-ticFoo)显得很臃肿。使用装饰器，可以替换掉上面的代码
        class MyClass(object):
            @staticmethod
            def staticFoo() :
                :
    此外，装饰器可以如同函数一样“堆叠”起来
        @deco2
        @deco1
        def func(arg1,arg2,...) : pass
    这里和创建一个数组函数是等价的
        def func(arg1,arg2,...) : pass
        func = deco2(deco1(func))

        - 有参数和无参数的装饰器
            是的，装饰器语法一开始有点犯迷糊，但是一旦适应了，那么困扰我们的就是什么时候使用带参数的装饰器。没有参数的情况下，一个装饰器如：
                @deco
                def foo() : pass
            非常直接
                foo = deco(foo)
            带参数的装饰器decomaker():
                @decomaker(deco_args)
                def foo() : pass
            需要自己返回以函数作为参数的装饰器。换句话说，decomaker() 用 deco_args 做了些事情并返回函数对象，而该函数对象正是以foo作为其参数的装饰器。简单的说:
                foo = decomaker(deco_args) (foo)
            这里有一个含有多个装饰器的例子，其中的一个装饰器带有一个参数：
                @deco1(deco_arg)
                @deco2
                def func() : pass
            等价于
                func = deco1(deco_arg) (deco2 (func))
        - 什么是装饰器
            现在我们知道装饰器实际就是函数。我们也知道他们接受函数对象。一般来说，当你包装一个函数的时候，你最终会调用他。最棒的是我们能在包装的环境下在适当的时机调用他。我们在执行函数之前，可以运行些预备代码，也可以在执行代码之后做些清理工作。所以当你看见一个装饰器函数的时候，很可能在里面找到这样一些代码，他定义了某个函数并在定义内的某处嵌入了对目标函数的调用或者至少一些引用。
        - 修饰符距离

            参见例如：deco.py

# 11.4 传递函数
在Python中函数，函数是可以被引用的（访问或者以其他变量作为其别名），也作为参数传入函数，以及作为里诶包和字典等容器对象的元素函数有一个独一无二的特征使他同其他对象区分开来。
因为所有的对象都是通过引用来传递的，函数也不例外。当对一个变量赋值的时候，实际是将相同对象的引用赋值给这个变量。如果对象是函数的话，这个对象所有的别名都是可调用的。
    def foo():
        pass
    
    bar = foo
    
    bar()

当我们把 foo 赋值给 bar 时，bar 和 foo 引用了一个函数对象，所以能以和调用 foo() 相同的方式来调用 bar()
下面我们可以深入我们引用的例子，我们甚至可以把函数作为参数传入其他函数来进行调用
    def bar(argfunc):
        argfunc()

    bar(foo)
注意到函数对象 foo 被传入到 bar() 中。bar() 调用了 foo()

# 11.5 Formal Arguments
Python函数的形参集合由在调用时要传入函数的所有参数组成，这些参数与函数声明中的参数精确的配对。
参数中包括了所有的必要参数（按照正确的顺序来传入的参数）、关键字参数（不需要按照特性的顺序来传入参数，但是带有参数列表中定义过的关键字）、以及一些默认参数
    | 位置参数
    位置参数必须在被调用函数中被定义的参数顺序一致来传递，并且（如果）么有任何默认参数的话，那么传入的参数的精确数目必须和定义的一样。
    | 默认参数
    运用默认参数能让程序的健壮性上升至极高级别
    所有的位置参数都要在默认参数前面

# 11.6 可变长度的参数
处理业务中我们可能会遇到处理可变参数的业务。这时候我们需要使用可变的参数列表。这类参数在函数中不是显示命名的，因为参数的数目在运行时之前是未知的（甚至是在运行期间，每次的调用也都是不同的）这种我们没办法显示的定义参数。
这里我们使用 * 和 ** 来定义关键字参数和非关键字参数（元组和字典的方式），这里我们仍然使用这种方式
    | 非关键字可变长参数（元组）
    当函数在调用的时候所有的形参（必须的和默认的）都要赋值给在函数中定义的相对应的局部变量。剩下的非关键字参数按照顺序插入到一个元组中便于访问。
    可变的参数元组必须在必须和默认的参数之后，带元组（或者非关键字可变长度参数）的函数普遍语法：
    def function_name ([formal_args,] *vargs_tuple) :
        pass
    星号操作符之后的形参将作为元组传递给函数，元组保存了所有传递给函数的‘额外’的参数，如果么有就为空。
    只要在函数调用时给出不正确的函数参数数目，就会产生一个 TypeError 异常。通过末尾增加一个可变的参数列表变量，我们就能处理当超出数目的参数被传入函数的情形，因为所有的额外（非关键字参数）会被添加到变量参数元组
    | 关键字变量参数（字典）
    当我们有不定数目的或者额外集合的关键字情况，我们就需要用到关键字变量参数，参数被放入到一个字典中，字典的键为参数名。
    def function_name ([formal_args,] [*vargs_tuple,] **vargsd)
        pass
    这里为了区分关键字参数和非关键字参数，使用了双星号（**）来定义可变的关键字参数。这里的（**）是被重载的，以便不与幂运算发生混淆。
    | 调用带有可变长参数对象函数
    - 函数式编程举例
        函数式编程的另一个有用的应用出现在调试和性能测量方面上。
        你正在使用需要每晚都被完全测试或通过回归，或需要给对潜在改善进行多次迭代计时的函数来工作。你所要做的就是创建一个设置测试环境的诊断函数，然后对有疑问的地方，调用函数。因为系统应该是灵活的，所以想testee函数作为参数传入。那么这样的函数对，timeit() 和 testit() ，可能会对如今的软件开发者有帮助。

# 11.7 函数式编程
Python不是也不大可能会成为一种函数式编程语言，但是它支持许多有价值的函数式编程语言构建。也有写表现的像函数式编程机制但是从传统上也不能被认为是函数式编程语言的构建。Python提供的以四种内建函数和lambda表达式的形式出现。
    | 匿名函数 与 lambda
    lambda [arg1[,arg2,... argN]] : expression
    Python 允许用 lambda 关键字创造匿名函数。
    -------------------------------------------------------------------------------------
    在我们看任何一个使用 lambda 的例子之前，我们已于复习下单行语句，然后展示下 lambda 表达式的相似之处。
    def true():
        return True
    上面的函数没有带任何的参数，并且总是返回True。Python语句中单行函数可以和标题写在同一行。
    def true() : return True
    我们这里使用的 ture() 函数，使用 lambda 的等价表达式（没有参数，返回一个True）为：
    lambda : True
    命名的 true() 函数的用法相当的明显，但是 lambda 就不是这样。我们需要在某些地方用它进行赋值吗？一个 lambda 函数自己就是无目的服务，
    
    >>> lambda : True
    <function <lambda> at 0x10c4b1938>

    在上面的例子中，我们简单的用 lambda 创建了一个函数（对象），但是既没有在任何地方保存他，也没有调用它。这个函数对象的引用计数在函数创建时被设置为 True ，但是因为没有引用保存下来，计数又回到0，然后被垃圾回收掉。为了保留这个对象，我们将它保存到一个变量中，以后可以随时调用

    >>> true = lambda : True
    >>> true()
    True

    这里用它赋值看起来非常有用。相似的，我们可以把 lambda 表达式赋值给一个如列表和元组的数据结构，其中，基于一些输入标准，我们可以选择那些函数可以执行，以及参数应该是什么

    def add(x,y) : return x + y   <------>   lambda x,y : x + y

    我们现在来设计一个带两个数字或者字符串参数，返回数字之和或者已经拼接的字符串的函数。

    def usuallyAdd2 (x,y = 2) : return x + y    <-----> lambda x,y = 2 : x + y
    def showAllAsTuple (*z) : return z   <-----> lambda *z : z

    举例说明
    >>> a = lambda x , y = 2 : x + y
    >>> a(3)
    5
    >>> a(3,5)
    8
    >>> a(0)
    2
    >>> b = lambda *z : z
    >>> b(23,'zyx')
    (23, 'zyx')
    >>> b(42)
    (42,)

    | 内建函数 apply()、filter()、map()、reduce()
    这些函数提供了在Python中可以找到的函数式编程的特征。

    — apply(func[,nkw][,kw]) : 用可选的参数来调用func,nkw为非关键字参数，kwWie关键字参数；返回值是函数调用的返回值
    现在允许变量参数的元组以及关键字可变参数的字典，逐渐摒弃不用

    — filter(func,seq) : 调用一个布尔函数 func 来迭代遍历每个 seq 中的元组；返回一个是 func 返回值为 true 的元素的序列
    def filter(bool_func,seq):
        filter_seq = []
        for eachItem in seq:
            if bool_func(eachItem):
                filter_seq.append(eachItem)
        return filter_seq

    - map(func,seq1[,seq2...]) : 将函数 func 作用与给定序列的每个元素，并用一个列表来提供返回值；如果 func为 None，func表现为一个身份函数，返回一个含有每个序列中元素集合的 n 个元组的列表。
    def map(func,seq):
        mapped_seq = []
        for eachItem in seq:
            mapped_seq.append(func(eachItem))
        return mapped_seq

    - reduce(func,seq[,init]) : 将二元函数作用与seq序列的元素，每次携带一对（先前的结果以及下一个序列元素），连续的将现有的结果和下一个值作用在获得的随后的结果上，最后减少我们的序列为一个单一的返回值；如果初始值 init 给定，第一个比较会是 init 和第一个序列元组而不是序列的头两个元素。
    reduce(func,[1,2,3]) = func(func(1,2),3)
    def reduce(bin_func,seq,init=None):
        Iseq = list(seq)              # convert to list
        if init is None:              # initializer ?
            res = lseq.pop(0)         # no
        else :
            res = init                # yes
        for item in lseq:             # redece sequence
            res = bin_func(res,item)  # apply function
        return res                    # return result

    | 偏函数应用
    currying 的概念将函数式编程的概念和默认参数以及可变参数结合在一起。
    一个带 n 个参数，curried的函数固化第一个参数为固定参数，并返回另一个带 n-1 个参数对象，分别类似于 LISP 的原始函数 car 和 cdr 的行为。
    Currying 能泛化成为偏函数应用（partial function application,PFA)，这种函数将任意数量（顺序）的参数的函数转化成另一个带剩余参数的函数对象。
    在某种程度上，似乎和不提供参数，就会使用默认参数一样。但是在 PFA 例子中，参数不需要调用函数的默认值，值需要明确的调用集合。你可以有很多的偏函数调用，每个都能用不同的参数传给函数，这就是不能使用默认参数的原因。
    - 简单的函数式例子
        参见 PFA.py
    - 警惕关键字
        举例，如果穿件了不带关键字的偏函数，比如，baseTwo-BAD = partial(int,2) ，这样可能会让参数以错误的顺序传入 int(),因为固定参数总是放在运行时刻参数的左边
    - 简单的GUI例子
        PFA 也扩展到所有可调用的东西，如类和方法。一个使用PFA的优秀的例子是提供了 “部分gui模范化”。GUI小部件通常有很多的参数，如文本、长度、等。
        参见 GUI.py

# 11.8 变量作用域
标识符的作用域是定义为其生命在程序里的可应用范围。
变量可以是局部变量或者是全局变量
    | 全局变量与局部变量
    定义在函数内部的变量有局部作用域，在一个模块中最高级别的变量有全局作用域。
    当搜索一个标识符的时候，Python先从局部作用域开始搜索。如果在局部作用域内没有找到那个名字，那么久一定会在全局与找这个变量，否则就会抛出NameError异常。
    所以局部变量是可以覆盖全局变量的
    | global 语句
    | 作用域的数字
    Python从语法上支持多个函数嵌套级别。（Python 2.1 以前）虽然存在多个函数的嵌套，但你不能访问超过两个作用域。
    | 闭包
    由于Python的静态嵌套域，定义内部函数变得很有用处。如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包（closure）。
    定义在外部函数内的但由内部函数引用或者使用的变量被称为自由变量。
    闭包将内部函数自己的代码和作用域以及外部函数的作用结合起来。
    闭包的词发变量不属于全局名称空间域或者局部的--而是属于其他的名称空间，带着“流浪”的作用域。
    闭包对于安装计算、隐藏状态和在函数对象和作用域中随意的切换是很有用的。闭包在GUI或者在很多API支持回调函数的时间驱动编程中很有用处。
    - 简单的闭包举例
        参见 counter.py
        解释：counter()做的唯一一件事情就是接受一个初始化的值来开始计数，并将该值赋值给了列表 count 唯一一个成员。然后定义一个 incr() 的内部函数。通过在内部使用变量 count，我们创建了一个闭包，因为他现在携带了整个 counter() 作用域。incr() 增加了正在运行的 count 然后返回他。然后最后的魔法就是 counter() 返回一个 incr,一个可调用的函数对象。
    | 作用域 和 lambda
    Python的 lambda 匿名函数遵循和标准函数一样的作用域规则。一个 lambda 表达式定义了新的作用域。就像函数定义，所以这个作用域处理局部 lambda 函数，对于程序其他部分我们是不能访问的。
    | 变量作用域 和 名称空间

# 11.9 递归

# 11.10 生成器
迭代器背后的有效性以及他们如何给非序列对象一个序列的迭代器接口。这很容易明白就是仅仅实现一个方法，用于调用获得下个元素的 next().
然而除非你实现了一个迭代器的类，迭代器真正的并没有那么“聪明”。
生成器的动机之一：就是调用函数强大到在迭代中以某种方式生成下一个值，并返回和 next() 调用一样简单的东西、
生成器的动机之二：协同程序的概念。协同程序是可以运行的独立函数调用，可以暂停或者挂起，并从程序离开的地方继续或者重新开始。在有调用者和（被调用者）协同程序也有通信。
举例说明就是：当协同程序暂停的时候，我们能从其中获得一个中间的返回值，当调用回到程序中时，能够传入额外的或者改变了的参数，但仍能够从我们上次离开的地方继续，并且所有状态完整。挂起返回出中间值并多次继续的协同程序被称为生成器、
语法上讲：Python生成器就是一个带有 yield 语句的函数
    | 简单的生成器特性
    与迭代器类似，生成器以另外的方式运作：当达到一个真正的返回或者函数结束没有更多的值返回，一个 StopIteration 异常就会抛出
    | 加强的生成器特性
    我们除了可以 next() 来获得下个生成的值，还可以将之回送给生成器 send() ,在生成器中抛出异常，以及要求生成器退出 close()
