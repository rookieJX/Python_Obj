# 11.1 什么是函数
函数是对程序逻辑进行结构化或过程化的一种编程方法。
    | 函数 VS 过程
    我们经常拿函数可过程比较。两者都是可以被调用的实体，但是传统意义上的函数或者“黑盒”，可能不带任何输入参数，经过一定的处理，最后向调用者传回返回值。其中一些函数则是布尔类型的，返回一个“是”或者“否”的回答，更确切的说，一个非零或者零值。而过程是简单、特殊、没有返回的函数。
    | 返回值与函数类型
    函数会向调用者返回一个值，而实际编程中大部分偏函数更接近过程，不显示的返回任何东西。把过程看待成函数的语言通常对于“什么都不返回“的函数设定了特殊的类型或者值的名字。
    Python里的函数可以返回一个值或者对象。只是在返回一个容器对象的时候有点不同，看起来像是能返回多个对象。（比如：你不能拿着大量零散的商品离开商店，但是你可以将他们放在一个购物袋中，然后带着袋子离开商店）
    当没有显示的返回元素或者如果返回None时，Python会返回一个None。那么调用者接收的就是Python返回的那个对象，且对象的类型仍然相同。
    如果函数返回多个对象，Python把他们聚集起来并以一个元组返回。
# 11.2 调用函数
    | 函数操作符
    用一堆圆括号调用函数。
    | 关键字参数
    关键字参数概念仅仅针对函数的调用。
    def foo(x):
        foo_suit
    标准调用foo(): foo(42) foo('bar') foo(y)
    关键字调用foo(): foo(x=2) foo(x='bar') foo(x=y)
    | 默认参数
    默认参数就是声明了默认值的参数。因为给参数赋予了默认值，所以在函数调用时，不响该参数传入值也是允许的。
    | 参数组
    Python同样允许程序员执行一个没有显示定义参数的函数，响应的方法是通过一个把元组（非关键字参数）或字典（关键字参数）作为参数组传递给函数。
    func(*tuple_grp_nonkw_args,**dict_grp_kw_args)
    其中tupletuple_grp_nonkw_args是以元组形式体现的非关键字参数，
    dict_grp_kw_args是装有关键字参数的字典。
    实际上也可以给出形参，这些参数包括标准的位置参数和关键字参数，所以在Python中完整的语法是：
    func(position_args,keyword_args,*tuple_grp_nonkw_args,**dict_grp_kw_args)

    例如：easyMath.py函数中
# 11.3 创建函数
    | def语句
    函数是用 def 语句来创建的
    | 声明与定义比较
    在一些编程语言中，函数声明和函数定义是分开的。一个函数声明包括提供对函数名，参数的名字（传统上还有参数的类型），但不必给出函数的任何代码，具体的代码通常属于函数定义的范畴。
    在声明和定义有区别的语言中，往往是因为函数的定义可能和其声明放在不同的文件中。Python将这两者视为一体，函数的子句由声明的标题行以及随后的定义体组成。
    | 前向引用
    Python不允许在函数未声明之前对其进行引用或者调用。
    | 函数属性
    你可以获得每个Python模块、类和函数中任意的名称空间。你可以在模块foo和bar里都有名为x的一个变量，但是在将这两个模块导入你的程序后，仍然可以使用这两个变量。所以，即使在两个模块中使用了相同的变量名字，这也是安全的，因为句点属性标识对于两个模块意味了不同的命名空间
    函数属性是Python另外一个使用了句点标识并拥有名称空间的领域
    | 内部/内嵌函数
    在函数体内创建另外一个函数（对象）是完全合法的。这种函数叫做内部/内嵌函数。因为Python现在支持静态的嵌套域
        创建一个内嵌函数
        def foo():
            def bar():
                print 'bar() called'
            print 'foo() called'
            bar()
        foo()
        bar()

        例如：inner.py
    内部函数有意思的方面在于整个函数体都在外部函数的作用域（即是你可以访问一个对象的区域）之内如果没有任何 bar() 的外部引用，那么除了在函数体内，任何地方都不能对其进行调用。
    | 函数（与方法）装饰器
    装饰器背后的主要动机源自Python面向对象编程。装饰器是在函数调用之上的修饰。这些修饰仅仅是当声明一个函数或者方法的时候，才会应用的额外调用。
    装饰器的语法是以 @ 开头，接着是装饰器函数的名字和可选参数。紧跟着装饰器声明的是被装饰函数和装饰函数的可选参数。
    @decorator(dec_opt_args)
    def func2Bdecorated(func_opt_args):
    :
    装饰器语法是如何产生的呢？
    在以前当静态方法和类方法被加入到Python中的时候，实现方法很笨拙
        class MyClass(object):
            def staticFoo():
                :
            staticFoo = staticmethod(staticFoo)
                :
    在这个类的声明中，我们定义了叫 staticFoo() 的方法。现在因为打算让他成为静态方法。接着用 staticmethod() 内建函数来将这个函数“转化”为静态方法，但是在 def staticFoo() 后跟着 staticFoo = staticmethod(sta-ticFoo)显得很臃肿。使用装饰器，可以替换掉上面的代码
        class MyClass(object):
            @staticmethod
            def staticFoo() :
                :
    此外，装饰器可以如同函数一样“堆叠”起来
        @deco2
        @deco1
        def func(arg1,arg2,...) : pass
    这里和创建一个数组函数是等价的
        def func(arg1,arg2,...) : pass
        func = deco2(deco1(func))

        - 有参数和无参数的装饰器
            是的，装饰器语法一开始有点犯迷糊，但是一旦适应了，那么困扰我们的就是什么时候使用带参数的装饰器。没有参数的情况下，一个装饰器如：
                @deco
                def foo() : pass
            非常直接
                foo = deco(foo)
            带参数的装饰器decomaker():
                @decomaker(deco_args)
                def foo() : pass
            需要自己返回以函数作为参数的装饰器。换句话说，decomaker() 用 deco_args 做了些事情并返回函数对象，而该函数对象正是以foo作为其参数的装饰器。简单的说:
                foo = decomaker(deco_args) (foo)
            这里有一个含有多个装饰器的例子，其中的一个装饰器带有一个参数：
                @deco1(deco_arg)
                @deco2
                def func() : pass
            等价于
                func = deco1(deco_arg) (deco2 (func))
        - 什么是装饰器
            现在我们知道装饰器实际就是函数。我们也知道他们接受函数对象。一般来说，当你包装一个函数的时候，你最终会调用他。最棒的是我们能在包装的环境下在适当的时机调用他。我们在执行函数之前，可以运行些预备代码，也可以在执行代码之后做些清理工作。所以当你看见一个装饰器函数的时候，很可能在里面找到这样一些代码，他定义了某个函数并在定义内的某处嵌入了对目标函数的调用或者至少一些引用。
        - 修饰符距离

            参见例如：deco.py
